using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
using System.Data.Common;
using System.Xml.Linq;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;

namespace testconsole2013
{
    class Program
    {
        static void Main(string[] args)
        {
           ListNode linkList= new ListNode(1,new ListNode(2,new ListNode(3,new ListNode(4,new ListNode(5)))));            
           var solution = new Solution();       
           var result = solution.OddEvenList(linkList);
           Console.WriteLine(result);
           Console.ReadKey();

        }

        public class ListNode
        {
            public int val;
            public ListNode next;
            public ListNode(int val = 0, ListNode next = null)
            {
                this.val = val;
                this.next = next;
            }
        }
        //2023.0806.0153
        public class Solution
        {
            public ListNode OddEvenList(ListNode head)
            {
                if (head is null || head.next is null) return head;

                ListNode oddStepNode = head;
                ListNode evenStepNode = head.next;
                ListNode evenNode = head.next;//存even的起始node，會隨while動作只存even node， head則是只剩odd node

                //兩個while其實一樣因為oddStepNode.next其實就是evenStepNode，因為每次loop兩個node都會移動
                //while (oddStepNode.next != null && evenStepNode.next != null)
                while (evenStepNode != null && evenStepNode.next != null)
                {
                    oddStepNode.next = oddStepNode.next.next;//直接指定下個odd
                    evenStepNode.next = evenStepNode.next.next;//直接指定下個even
                    //移動往後處理
                    oddStepNode = oddStepNode.next;
                    evenStepNode = evenStepNode.next;                    
                }
                //此時oddStepNode的頭node是head，且是head的尾，此部分evenStepNode的頭node是evenNode
                oddStepNode.next = evenNode;//將head(只剩odd node)的尾接上evenNode(只存odd node)

                return head;
            }
        }
        //這題有趣的是linklist的記憶體指向操作方式，且是用手做class，所以這種記憶體指向可能是預設的??那就值得深思了
        //然後基本上都用記憶體指向，所以也可以說是沒用額外記憶體?
        //有趣的hint 1,2,3,4若將1->3，記憶體路徑是a : 1,3,4但還有 b: 2,3,4存在，也就是此題的【evenNode】
        //基本抄的
        //https://leetcode.com/problems/odd-even-linked-list/solutions/78079/simple-o-n-time-o-1-space-java-solution/?envType=study-plan-v2&envId=leetcode-75

    }
}
